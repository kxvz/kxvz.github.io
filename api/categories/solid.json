{"name":"solid","slug":"solid","count":1,"postlist":[{"title":"SOLID原则","slug":"SOLID原则","date":"2018-12-11T10:21:10.000Z","updated":"2018-12-11T10:21:10.181Z","comments":true,"path":"api/articles/SOLID原则.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"面向对象设计的SOLID原则\"><a href=\"#面向对象设计的SOLID原则\" class=\"headerlink\" title=\"面向对象设计的SOLID原则\"></a>面向对象设计的SOLID原则</h1><pre><code>S.O.L.I.D是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。\n</code></pre><h3 id=\"单一责任原则：\"><a href=\"#单一责任原则：\" class=\"headerlink\" title=\"单一责任原则：\"></a>单一责任原则：</h3><pre><code>当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 \n</code></pre><h3 id=\"开放封闭原则\"><a href=\"#开放封闭原则\" class=\"headerlink\" title=\"开放封闭原则\"></a>开放封闭原则</h3><pre><code>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。\n</code></pre><h3 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h3><pre><code>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系 \n</code></pre><h3 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h3><pre><code>1. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 \n\n2. 抽象不应该依赖于细节，细节应该依赖于抽象 \n</code></pre><h3 id=\"接口分离原则\"><a href=\"#接口分离原则\" class=\"headerlink\" title=\"接口分离原则\"></a>接口分离原则</h3><pre><code>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。\n</code></pre>","text":"面向对象设计的SOLID原则S.O.L.I.D是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。单一责任原则：当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE TH","link":"","raw":null,"photos":[],"categories":[{"name":"solid","slug":"solid","count":1,"path":"api/categories/solid.json"}],"tags":[{"name":"solid","slug":"solid","count":1,"path":"api/tags/solid.json"}]}]}